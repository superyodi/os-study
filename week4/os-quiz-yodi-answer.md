# 4주차 오에스 퀴즈





## 세마포어

*여기서 프로세서는 절차처리기라는 의미로 사용됨*

+ 세마포어에 대해 설명하라
  
  + 답: 
  
    프로세스 동기화 문제를 해결하기 위해 고안된 추상자료형
  
    + 자원 차지, 반납을 원자적으로 실행한다
    + counting 세마포어: 자원 갯수 counting
    + binary 세마포어: 자원 접근가능 여부 판단 (lock, unlock)
+ 세마포어 연산 두가지를 적고 어떤 역할을 하는지 설명하라
  + (   P(S)     ):    자원 차지            
  + (    V(S)     ):   자원 반납                      

+ Mutex에 대해 설명하라
  
  + 답:  임계영역에 하나의 프로세서만 접근하게 하기위해 사용되는 binary semaphore
    +  Lock, unlock을 표시하기 위해 사용
    + 하나의 프로세서만 접근가능함









## 프로세스 동기화 문제



다음은 프로세스 동기화 상황에서 발생할 수 있는 고전적인 문제 3가지다.

각 코드를 읽고 함수들의 역할을 대략적으로 설명하라 

### 생산자와 소비자

<img width="820" alt="스크린샷 2021-04-19 오후 7 05 04" src="https://user-images.githubusercontent.com/31922389/115224980-8837af00-a148-11eb-844b-d8ce023da50a.png">

1. Producer
   + P(empty): 
     + 빈 버퍼의 갯수를 판별
     + 만약 생산자 입장에서 빈 버퍼가 없을때 빈 버퍼가 생길때까지 기다림 
   + P(mutex):
     + 빈 버퍼에 새 item 생산
     + 동기화를 위해 위 작업을 할 동안 mutex로 lock을 건다
   + V(mutex):
     + 버퍼에 대한 작업을 마쳤으면 V(mutex)로 unlock
   + V(full):
     + empty버퍼에서 full 버퍼를 생산했으니 V(full)로 full 버퍼의 자원을 반납
2. Consumer
   + P(full):
     + full 버퍼의 갯수를 판별
     + 만약 소비자 입장에서 full 버퍼가 없을때 full 버퍼가 생길때까지 기다림
   + P(mutex):
     + 풀 버퍼의 item 소비
     + 동기화를 위해 위 작업을 할 동안 mutex로 lock을 건다
   + V(mutex):
     + 버퍼에 대한 작업을 마쳤으면 V(mutex)로 unlock
   + V(empty):
     + empty버퍼를 생산했으니 V(empty)로 empty 버퍼의 자원을 반납





### Writer와 Reader

<img width="872" alt="스크린샷 2021-04-19 오후 7 14 14" src="https://user-images.githubusercontent.com/31922389/115225086-a4d3e700-a148-11eb-8823-49d33e673495.png">



+ <u>Reader</u> 부분의 코드를 대략적으로 설명하여라  (세마포어 연산들을 기준으로)

  + 답: 

    (전제 조건)

    + 리더가 리드할 동안 다른 리더들은 접근 가능하다 

    + 라이터가 라이트할 동안 다른 리더 및 라이터들은 접근 불가능하다

      

    + 여기서 P(mutex)/V(mutex)는 readcount를 위한 상호배제를 위해 사용된다
    + readcount가 1 일때 (일단 reader가 들어오면 ) P(db)를 해서 writer에 대한 db접근을 막는다. 
    + readcount가 0일때 더이상 읽을 reader가 없다는 의미니까 V(db)로 writer에 대한 db접근을 unlock한다. 

+ Writer 부분에서 starvation이 발생하는 이유는 무엇인가?
  
  + 답: 라이터는 리더들이 다 읽을때까지 db접근못하니까 굶어주거~~~~~~





### 식사하는 철학자



+ 아래 코드가 실행되면 발생하는 문제에 대해 설명하라
  + 답:  모든 철학자가 동시에 배고파서 왼쪽 포크를 든 채 오른쪽 사람이 자기의 왼쪽 포크를 내려놓을때까지 기다린다. 



<img width="837" alt="스크린샷 2021-04-20 오후 4 55 45" src="https://user-images.githubusercontent.com/31922389/115382027-27bf7500-a20f-11eb-8973-d84ad244fdac.png">





+ 위의 코드로 발생할 수 있는 문제를 해결하기 위해 젓가락을 두쪽 다 들 수 있는 상황에서 젓가락을 들도록 하는 코드를 작성하였다.

  코드에 대한 대략적인 설명을 작성하라 





<img width="910" alt="스크린샷 2021-04-20 오후 5 02 19" src="https://user-images.githubusercontent.com/31922389/115382143-4f164200-a20f-11eb-930f-23d31124ed91.png">



<u>변수 설명</u>

+ self[len(philosopher)] : 젓가락 보유하고있는 여부 나타내는 flag

+ state[len(philosopher)] : 지금 철학자들의 상태 

  + thinking, hungry, eating 세가지 상태가 있음 

+ mutex: state의 상호배제를 위해 사용 

  



<u>함수 설명</u>

+ pickup(int i) : 철학자 i가 젓가락을 들때 사용하는 함수

  철학자 i가 밥먹으려는 상황. 

  1. mutex -> 상태 변경을 위한 상호배제 
  2. 상태를 배고픔으로 바꿈 
  3. 지금 먹을 수 있는지 test()
  4. 밥먹고나서 P()로 자원 -- ----> 사실 여기 세마포어 연산 잘 이해안됨. P/V 바뀐것같음

  

  

  

+ putdown(int i): 철학자 i가 젓가락을 놓을때  사용하는 함수

  1. mutex로 상태 변경 -> thinking
  2. test로 양 옆사람 밥 먹을수 있나 확인 



​	



+ test() 

  + 지금 밥 먹을 수 있는지 확인 
    + 양옆사람이 밥 안먹고 있음 && 내가 배고픔
  + 조건 맞음 ---> V연산으로 자원 1 추가 

  

  

## 모니터

+ 세마포어의 문제점은 무엇인가? (세마포어를 사용하면 발생할 수 있는 상황)

  + 답: P 연산 다음에 V 연산이 이루어져야하는데 모두 개발자가 수동으로 해야한다. 잘못이뤄지면 starvation 또는 deadlock 현상 발생가능성 있다.

    

    

+ 모니터에 대해 설명하라.

  + 답:  모니터에서 자원을 획득하고 반납하는 연산을 관리한다. 프로그래밍 언어에서 관리하는 등 개발자가 관리하지않아도 됨.

    임계영역에 이미 다른 프로세스가 있다면 모니터가 막아서 다른 프로세스를 대기열에 놓도록 함 .

    프로세스 동기화 가능성을 애초에 차단

    



## 데드락





+ 데드락에 대해 설명하라 (어떤 상황인지)
  + 답: 요청한 자언을 할당받을때까지 할당된 자언을 놓지 않아서 ㅁㄹ려있는 현상
    + 모든 철학자가 동시에 배고파서 왼쪽 포크를 든 채 오른쪽 사람이 자기의 왼쪽 포크를 내려놓을때까지 기다린다.  <- 이런 상황



### 데드락 발생조건 4가지

1. 상호 배제

   내가 가지고 있는 자언을 남이 가질 수 없음

2. 논-preempt

   내가 가진 자원을 내가 반납전까지 누가 가져갈 수 없음

3. 자원 확보

   1.   내가 요청한 자원이 할당될때까지 보유하고 있는 자원 꽉 쥐고있음

4. 사이클

   1.   자원할당그래프에 사이클이 있어야함







+ 다음의 자원 할당 그래프를 보고 데드락 여부를 판단하고 그 이유를 써라

  + <img width="343" alt="스크린샷 2021-04-21 오전 11 17 12" src="https://user-images.githubusercontent.com/31922389/115659950-455b1e80-a376-11eb-90fc-c8edbb6fb157.png" style="zoom: 100%;">
    + 답: 데드락! 
  + <img width="361" alt="스크린샷 2021-04-21 오전 11 18 45" src="https://user-images.githubusercontent.com/31922389/115660404-ed70e780-a376-11eb-9a6e-81c9cf5bc2d8.png">
    + 답: 데드락

  

  

  

  

  

  

  

  + <img width="387" alt="스크린샷 2021-04-21 오전 11 18 45 복사본" src="https://user-images.githubusercontent.com/31922389/115660438-f9f54000-a376-11eb-9639-ce7f680c9046.png">

    + 답: 데드락 아님

      

      





### 데드락 처리방법 4가지

다음은 데드락을 처리하는 4가지 방식이다. 

어떤 방식으로 처리하는지 대략적으로 작성해라



 

데드락 사전 방지하는 방식

1. Deadlock Prevention      
   +  설명: 데드락이 일어날 수 있는 필요조건 4개를 애초에 방지
2. Deadlock Avoidance
   + 설명: 프로세스가 요청 할 수 있는 최대 자원의 갯수를 미리 declare하고 염두하면서 자원 할당
     + 문제점: 사용 가능성 자원을 너무 과하게 잡아서 지금 자원을 사용할 수 있어도 자원할당 안해줌 ---> 비효율적



데드락 사후 대처 방식

3. Deadlock Detection and recovery

   + 설명: 데드락이 일어나면 데드락이 일어난 부분을 찾아서 처리

     

4. .Deadlock Ignorance
   
   + 설명: 걍 무시하고 사용자가 알아서 하게 둠



### Deadlock Avoidance



Deadlock Avoidance는 자원의 상황에 따라 사용하는 알고리즘이 다르다. 

두가지 상황과 각 상황에서 사용되는 알고리즘을 설명하라. (알고리즘 이름을 정확히 몰라도 괜찮음, 대략적인 방식을 설명)

1. 동일 자원 인스턴스 하나
   + (알고리즘 설명) 자원할당 그래프 
     + 프로세스가 요청할 수 있는 자원을 점선으로 표시해서 요청 가능성을 염두한채 자원 할당
2. 동일 자원 인스턴스 여러개
   - (알고리즘 설명) Banker's Algorithm



+ Banker's Algorithm

  다음 그림을 보고 질문에 답하라

  

  <img width="937" alt="스크린샷 2021-04-21 오전 11 52 57" src="https://user-images.githubusercontent.com/31922389/115661691-d0d5af00-a378-11eb-8d69-88335da2dcbd.png">
  
  + Allocation:  처음 할당된 자원
  + Max: 프로세스가 진행하면서 최대로 요청할거라고 예상되는 수치
  + Available:  지금 남아있는 자원
  + Need:  최대요청자원 - 할당된 자원 

  <img width="905" alt="스크린샷 2021-04-21 오후 12 00 36" src="https://user-images.githubusercontent.com/31922389/115661792-fa8ed600-a378-11eb-81cb-cc391ad62460.png">



+ P4 (3,3,0) 할당 가능? 지금안됨
  + p1 다음에 수행하면 가능
+ P0 (0,2,0) 할당가능? 지금 안됨
  + 이유: 가용자원이 최대 할당가능자원 커버 못침
  + p4 다음에 가능 



























